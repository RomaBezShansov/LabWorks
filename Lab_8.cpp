// Файл HeapInt.h
#pragma once // 1
#include <cassert>

class HeapInt
{
private:
    int* heapValue; // 2

public:
    // 3
    inline HeapInt(int val) // : heapValue(val)
    {
    heapValue = val;
    }
        // 4
        : heapValue(new int{ val })
    {
    }

    inline ~HeapInt()
    {
        // Заметка: delete проверяет на nullptr сам.
        delete heapValue; // 5
    }

    inline int& asRef()
    {
        assert(heapValue != nullptr); // 6
        return *heapValue;
    }

    HeapInt(const HeapInt& hello); // 7
    HeapInt(HeapInt&& hello);
    void operator=(const HeapInt& hello);
    void operator=(HeapInt&& hello);
};

// Файл main.cpp
#include "HeapInt.h"

void constructors()
{
    HeapInt a{5}; // 8
    HeapInt b{a}; // 9
    HeapInt c{std::move(a)}; // 10
    HeapInt d = b; // 11
    HeapInt e = std::move(b); // 12
    d = std::move(c); // 13
    d = e; // 14
}

// Файл HeapInt.cpp
#include "HeapInt.h"

// ... 15

Дан класс HeapInt выше, представляющий собой обертку для динамически выделенного инта. В отличии от обычного int*, этот тип не позволяет nullptr как валидное значение.

Класс следует RAII, выделяя память в конструкторе, и удаляя ее в деструкторе.

1) Почему поле heapValue (2) приватное?
параметр Private встроеный в класс и его не надо писать.

2) Что означает этот синтаксис (4)? Как его расписать в теле конструктора?

Ответ
Как скомпилировать это с помощью GCC?

Ответ
Зачем (1)? Какую ситуацию это предотвратит?

Ответ
Почему (3) определена как inline?

Ответ
Как можно обойти ограничение, что конструктор или функция должны быть inline?

Ответ
Зачем на (6) нужна проверка, если int* не может быть nullptr?

Подсказка
Деталь
Объясните, какой из конструкторов или перегруженных операторов вызовется для (8-14). Какие из них эквивалентны?

Как запретить синтаксис на (11-12)?

Подсказка
Определите на (15) конструкторы и операторы на (7).

Как определить конструктор или перегруженный оператор отдельно?
А что в них делать?
В какой еще ситуации вызовется rvalue reference перегрузка конструктора или оператора присваивания?

Перегрузка?
Ответ
Сколько раз вызовется деструктор для типа HeapInt после (14)?

Ответ
Объясните, какая по вашему мнению была мотивация того, что у этого типа не был определен дефолтный конструктор?

Определение понятия
Ответ
Объясните, почему считывать значение объекта после применения std::move это неправильная операция?

Ответ
Создайте функцию void swap(HeapInt& a, HeapInt& b), которая меняет значения, без выделения новой динамической памяти.